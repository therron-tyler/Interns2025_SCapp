# Needed libraries for the application
# install.packages(c("shiny", "dplyr", "tidyr", "readr", "ggplot2", "plotly", "patchwork", "RColorBrewer"))

library(shiny)
library(dplyr)
library(tidyr)
library(readr)
library(ggplot2)
library(plotly)
library(patchwork)
library(RColorBrewer)

# Set Shiny's upload limit to 600 MB
options(shiny.maxRequestSize = 600 * 1024^2)

# --- User Interface (UI) ---
ui <- fluidPage(
  titlePanel("Interactive Gene Expression Visualization Tool - Sohum, Suki, Kim, and Zach"),
  sidebarLayout(
    sidebarPanel(
      fileInput("expr", "1. Expression Matrix (.tsv or .tsv.gz)",
                accept = c(".tsv", ".tsv.gz")),
      fileInput("meta", "2. Metadata File (.tsv or .tsv.gz)",
                accept = c(".tsv", ".tsv.gz")),
      hr(),
      uiOutput("gene_ui"),
      uiOutput("group_ui"),
      uiOutput("split_ui"),
      # Added a checkbox to control Feature Plot behavior
      checkboxInput("color_by_gene", "Feature Plot: Color by gene expression", value = FALSE),
      p(strong("Note:"), "For Violin/Box plots, multiple genes will be shown in a grid.")
    ),
    mainPanel(
      tabsetPanel(
        tabPanel("Feature Plot", plotlyOutput("featPlot", height = "600px")),
        tabPanel("Bubble Plot", plotlyOutput("dotPlot", height = "800px")),
        tabPanel("Violin Plot", plotlyOutput("vlnPlot", height = "800px")),
        tabPanel("Box Plot", plotlyOutput("boxPlot", height = "800px")),
        tabPanel("Heatmap", plotlyOutput("heatmapPlot", height = "800px"))
      )
    )
  )
)

# --- Server Logic ---
server <- function(input, output, session) {
  
  # Reactive expression to load and merge data
  plot_data <- reactive({
    req(input$expr, input$meta)
    meta_df <- read_tsv(input$meta$datapath) %>%
      tibble::column_to_rownames(var = colnames(.)[1])
    expr_df <- read_tsv(input$expr$datapath)
    genes <- expr_df[[1]]
    mat <- as.matrix(expr_df[,-1])
    rownames(mat) <- genes
    t_mat <- t(mat)
    ordered_meta <- meta_df[rownames(t_mat), ]
    combined_df <- as.data.frame(t_mat) %>%
      mutate(cell = rownames(.)) %>%
      bind_cols(ordered_meta)
    return(combined_df)
  })
  
  # Dynamic UI rendering
  output$gene_ui <- renderUI({
    req(plot_data())
    all_cols <- colnames(plot_data())
    meta_cols <- c("cell", colnames(read_tsv(input$meta$datapath) %>% select(-1)))
    gene_choices <- setdiff(all_cols, meta_cols)
    selectInput("genes", "Select Gene(s):", choices = gene_choices, selected = gene_choices[1], multiple = TRUE)
  })
  output$group_ui <- renderUI({
    req(plot_data())
    meta_cols <- colnames(read_tsv(input$meta$datapath) %>% select(-1))
    group_choices <- grep("UMAP", meta_cols, value = TRUE, invert = TRUE)
    selectInput("group", "Group By (Categories/Colors):", choices = group_choices, selected = group_choices[1])
  })
  output$split_ui <- renderUI({
    req(plot_data())
    meta_cols <- colnames(read_tsv(input$meta$datapath) %>% select(-1))
    split_choices <- c("None", grep("UMAP", meta_cols, value = TRUE, invert = TRUE))
    selectInput("split", "Split By (Comparison Group):", choices = split_choices, selected = "None")
  })
  
  # --- Interactive Plotting Functions ---
  
  # 1. Feature Plot (UMAP)
  output$featPlot <- renderPlotly({
    req(plot_data(), "UMAP_Xaxis" %in% names(plot_data()), input$group)
    df <- plot_data()
    if (!input$color_by_gene) {
      # Color by metadata group
      p <- ggplot(df, aes(x = UMAP_Xaxis, y = UMAP_Yaxis, color = .data[[input$group]],
                          text = paste0("Cell: ", cell, "<br>Group: ", .data[[input$group]]))) +
        geom_point(size = 1, alpha = 0.8) +
        guides(color = guide_legend(override.aes = list(size = 3))) +
        labs(title = "UMAP Colored by Metadata Group", color = input$group) +
        theme_minimal()
    } else {
      # Color by gene expression
      req(input$genes)
      if (length(input$genes) == 1) {
        # Single gene expression
        p <- ggplot(df, aes(x = UMAP_Xaxis, y = UMAP_Yaxis, color = .data[[input$genes]],
                            text = paste0("Cell: ", cell, "<br>Expr: ", round(.data[[input$genes]], 2)))) +
          geom_point(size = 1, alpha = 0.8) +
          scale_color_viridis_c() +
          labs(title = paste("Expression of", input$genes), color = "Expression") +
          theme_minimal()
      } else {
        # Multiple genes: Calculate and plot a Module Score
        df$ModuleScore <- rowMeans(df[, input$genes, drop = FALSE], na.rm = TRUE)
        p <- ggplot(df, aes(x = UMAP_Xaxis, y = UMAP_Yaxis, color = ModuleScore,
                            text = paste0("Cell: ", cell, "<br>Score: ", round(ModuleScore, 2)))) +
          geom_point(size = 1, alpha = 0.8) +
          scale_color_viridis_c() +
          labs(title = "Module Score for Selected Genes", color = "Avg. Expr.") +
          theme_minimal()
      }
    }
    ggplotly(p, tooltip = "text")
  })
  
  # 2. Bubble Plot
  output$dotPlot <- renderPlotly({
    req(input$genes, input$group, plot_data())
    dot_plot_data <- plot_data() %>%
      select(all_of(c(input$genes, input$group, if(input$split != "None") input$split))) %>%
      pivot_longer(cols = all_of(input$genes), names_to = "gene", values_to = "expression")
    summary_df <- dot_plot_data %>%
      group_by(gene, .data[[input$group]], .add = TRUE) %>%
      { if (input$split != "None") group_by(., .data[[input$split]], .add = TRUE) else . } %>%
      summarise(avg_expr = mean(expression), pct_expr = (sum(expression > 0) / n()) * 100, .groups = "drop")
    p <- ggplot(summary_df, aes(x = gene, y = .data[[input$group]], size = pct_expr, color = avg_expr,
                                text = paste0("Avg. Expr: ", round(avg_expr, 2), "<br>% Expr: ", round(pct_expr, 2), "%"))) +
      geom_point(alpha = 0.8) +
      scale_color_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, name = "Avg. Expr.") +
      scale_size_continuous(name = "% Expr.") +
      labs(x = "Feature", y = "Cell Subset") +
      theme_bw() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))
    if (input$split != "None") {
      p <- p + facet_grid(rows = vars(.data[[input$split]]), scales = "free_y", space = "free_y")
    }
    ggplotly(p, tooltip = "text")
  })
  
  # 3. Violin Plot
  output$vlnPlot <- renderPlotly({
    req(input$genes, input$group, plot_data())
    plot_df <- plot_data() %>%
      pivot_longer(cols = all_of(input$genes), names_to = "gene", values_to = "expression")
    p <- ggplot(plot_df, aes(x = .data[[input$group]], y = expression)) +
      geom_violin(trim = FALSE, scale = "width", alpha = 0.7) +
      geom_jitter(size = 0.4, alpha = 0.3, height = 0, width = 0.2) +
      geom_boxplot(width = 0.1, fill = "white", outlier.shape = NA, alpha = 0.5) +
      labs(x = input$group, y = "Expression") +
      theme_bw() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none") +
      facet_wrap(~ gene, scales = "free_y", ncol = 1)
    if (input$split != "None") {
      p <- ggplot(plot_df, aes(x = .data[[input$group]], y = expression, fill = .data[[input$split]])) +
        geom_violin(position = position_dodge(width = 0.8), trim = FALSE, scale = "width", alpha = 0.7) +
        geom_boxplot(position = position_dodge(width = 0.8), width = 0.1, fill = "white", outlier.shape = NA, alpha = 0.5) +
        labs(x = input$group, y = "Expression", fill = input$split) +
        theme_bw() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "top") +
        facet_wrap(~ gene, scales = "free_y", ncol = 1)
    }
    ggplotly(p)
  })
  
  # 4. Box Plot
  output$boxPlot <- renderPlotly({
    req(input$genes, input$group, plot_data())
    plot_df <- plot_data() %>%
      pivot_longer(cols = all_of(input$genes), names_to = "gene", values_to = "expression")
    p <- ggplot(plot_df, aes(x = .data[[input$group]], y = expression, fill = .data[[input$group]])) +
      geom_boxplot() +
      theme_bw() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none") +
      labs(x = input$group, y = "Expression") +
      facet_wrap(~ gene, scales = "free_y", ncol = 1)
    if (input$split != "None") {
      p <- ggplot(plot_df, aes(x = .data[[input$group]], y = expression, fill = .data[[input$split]])) +
        geom_boxplot(position = position_dodge(width = 0.8)) +
        theme_bw() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "top") +
        labs(x = input$group, y = "Expression", fill = input$split) +
        facet_wrap(~ gene, scales = "free_y", ncol = 1)
    }
    ggplotly(p)
  })
  
  # 5. Heatmap (from Suki)
  output$heatmapPlot <- renderPlotly({
    req(plot_data(), input$genes)
    
    # Check if any genes are selected
    if (is.null(input$genes) || length(input$genes) == 0) {
      return(plot_ly() %>% layout(title = "Choose genes to view heatmap"))
    }
    
    # Extract the required data: a matrix of selected genes vs. all cells
    # The plot_data() reactive already has genes as columns and cells as rows.
    # We need to select the gene columns and transpose the matrix.
    mat <- plot_data() %>%
      select(all_of(input$genes)) %>%
      as.matrix() %>%
      t() # Transpose to get genes as rows, cells as columns
    
    # Pivot the matrix into a long format for ggplot
    df <- as.data.frame(mat) %>%
      mutate(Gene = rownames(.)) %>%
      pivot_longer(cols = -Gene, names_to = "Cell", values_to = "Expression")
    
    # Create the ggplot heatmap
    p <- ggplot(df, aes(x = Cell, y = Gene, fill = Expression)) +
      geom_tile() +
      scale_fill_viridis_c() + # Using viridis color scale from the simpler app
      theme_minimal() +
      theme(axis.text.x = element_blank(),
            axis.ticks.x = element_blank()) +
      labs(title = "Expression Heatmap",
           x = "Cells", y = "Genes")
    
    ggplotly(p)
  })
}

# Launch the Shiny app
shinyApp(ui, server)
