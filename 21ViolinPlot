#–––– Increase upload limit –––––
options(shiny.maxRequestSize = 600 * 1024^2)

#–––– Packages –––––
library(shiny)
library(data.table)
library(ggplot2)
library(viridis)
library(shinycssloaders)
library(plotly)

#–––– UI –––––
ui <- fluidPage(
  titlePanel("Single-cell Violin Plot Explorer (Interactive)"),
  sidebarLayout(
    sidebarPanel(
      fileInput("expr",   "Expression matrix (.tsv)", accept = ".tsv"),
      fileInput("meta",   "Metadata (.tsv)",        accept = ".tsv"),
      hr(),
      selectizeInput("genes", "Select gene(s):",
                     choices = NULL, multiple = TRUE,
                     options = list(placeholder = "Type to search…",
                                    maxOptions = 100)),
      selectInput("group",    "Group by (required):",    choices = NULL),
      selectInput("split_by", "Split by (optional):",    choices = NULL)
    ),
    mainPanel(
      # renderUI for dynamic height, wrapped in spinner
      withSpinner(uiOutput("vlnPlot_ui"), type = 6)
    )
  )
)

#–––– Server –––––
server <- function(input, output, session) {
  
  # 1) Header row of expression
  expr_header <- reactive({
    req(input$expr)
    names(fread(input$expr$datapath, nrows = 0))
  })
  
  # 2) First column (genes) for dropdown
  expr_genes <- reactive({
    req(input$expr)
    fread(input$expr$datapath, select = 1)[[1]]
  })
  
  # 3) Metadata
  meta_dt <- reactive({
    req(input$meta)
    dt <- fread(input$meta$datapath)
    setnames(dt, names(dt)[1], "cell")
    dt
  })
  
  # 4) Populate gene & meta selectors
  observeEvent(expr_genes(), {
    updateSelectizeInput(session, "genes",
                         choices  = expr_genes(),
                         selected = expr_genes()[1],
                         server   = TRUE)
  })
  observeEvent(meta_dt(), {
    cols <- setdiff(names(meta_dt()), "cell")
    updateSelectInput(session, "group",    choices = cols,      selected = cols[1])
    updateSelectInput(session, "split_by", choices = c(None = "", cols), selected = "")
  })
  
  # 5) Dynamic-height UI container for plotlyOutput
  output$vlnPlot_ui <- renderUI({
    req(input$genes)
    n    <- length(input$genes)
    cols <- if (n <= 2) n else 2
    rows <- ceiling(n / cols)
    height_px <- paste0(350 * rows, "px")
    plotlyOutput("vlnPlot", height = height_px, width = "100%")
  })
  
  # 6) Build & render the interactive violin plot
  output$vlnPlot <- renderPlotly({
    req(input$expr, input$meta, input$genes, input$group)
    
    path      <- input$expr$datapath
    genes     <- input$genes
    hdr       <- expr_header()
    meta      <- meta_dt()
    grp       <- input$group
    spl       <- input$split_by
    n_genes   <- length(genes)
    ncol_wrap <- if (n_genes <= 2) n_genes else 2
    
    withProgress(message = "Building violin(s)…", value = 0, {
      incProgress(0.1, detail = "Building grep pattern")
      esc     <- gsub("([\\^\\$\\.\\|\\(\\)\\[\\]\\*\\+\\?\\\\])", "\\\\\\\\1", genes)
      pattern <- paste0("^(", paste(esc, collapse = "|"), ")\\t")
      
      incProgress(0.1, detail = "Extracting lines")
      cmd  <- paste("grep -E", shQuote(pattern), shQuote(path))
      dt_s <- tryCatch(fread(cmd = cmd, header = FALSE, sep = "\t"),
                       error = function(e) NULL)
      if (is.null(dt_s) || nrow(dt_s) == 0) {
        showNotification("No matching genes found.", type = "error")
        return(NULL)
      }
      
      incProgress(0.1, detail = "Renaming columns")
      setnames(dt_s, hdr)
      setnames(dt_s, hdr[1], "gene")
      
      incProgress(0.15, detail = "Melting to long form")
      df_long <- melt(dt_s,
                      id.vars         = "gene",
                      variable.name   = "cell",
                      value.name      = "expression",
                      variable.factor = FALSE)
      
      incProgress(0.1, detail = "Joining metadata")
      df <- merge(df_long, meta, by = "cell", all = FALSE)
      df[, group := factor(get(grp))]
      if (nzchar(spl)) df[, split := factor(get(spl))] else df[, split := NULL]
      
      incProgress(0.15, detail = "Filtering for densities")
      if (nzchar(spl)) {
        cnts   <- df[, .N, by = .(gene, group, split)]
        keep   <- cnts[N >= 2, .(gene, group, split)]
        df_big <- merge(df, keep, by = c("gene", "group", "split"))
      } else {
        cnts   <- df[, .N, by = .(gene, group)]
        keep   <- cnts[N >= 2, .(gene, group)]
        df_big <- merge(df, keep, by = c("gene", "group"))
      }
      
      incProgress(0.35, detail = "Rendering plot")
      if (nzchar(spl)) {
        p <- ggplot(df_big,
                    aes(x = group, y = expression,
                        fill = split, group = interaction(group, split))) +
          geom_violin(trim = TRUE, color = "black", alpha = 0.6) +
          geom_jitter(aes(color = split),
                      position = position_jitterdodge(0.9, 0.15),
                      size = 0.6, alpha = 0.6) +
          scale_fill_viridis_d(name = spl) +
          scale_color_viridis_d(name = spl)
      } else {
        p <- ggplot(df_big,
                    aes(x = group, y = expression,
                        fill = group, group = group)) +
          geom_violin(trim = TRUE, color = "black", alpha = 0.6) +
          geom_jitter(aes(color = group),
                      position = position_jitter(0.15),
                      size = 0.6, alpha = 0.6) +
          scale_fill_viridis_d(guide = "none") +
          scale_color_viridis_d(guide = "none")
      }
      
      p <- p +
        facet_wrap(~ gene, scales = "free_y",
                   ncol = ncol_wrap, drop = FALSE) +
        labs(x = NULL, y = "Normalized Expression") +
        theme_minimal() +
        theme(
          panel.spacing = unit(1, "cm"),
          axis.text.x   = element_text(angle = 45, hjust = 1),
          strip.text    = element_text(size = 12),
          plot.margin   = margin(10, 10, 10, 10)
        )
      
      ggplotly(p, tooltip = c("group", "split", "expression")) %>%
        layout(legend = list(orientation = "h", x = 0.3, y = -0.1))
    })
  })
}

#–––– Launch App –––––
shinyApp(ui, server)
